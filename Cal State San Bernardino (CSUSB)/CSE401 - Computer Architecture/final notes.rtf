{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\froman\fcharset0 TimesNewRomanPSMT;}
{\colortbl;\red255\green255\blue255;\red26\green26\blue26;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs32 \cf2 401:\
Two out of three questions for my test were the second and third questions on the white board. The third question from the whiteboard says to convert the MIPS assembly code to C++ code. The second question gives you a pipeline and some instructions; then asks a few questions like how many stages and what operations take place in each of those stages. I would copy down all that info on the board, because I used it all.\'a0\
Last question:\
Assume address size is 40 bits for a computer with 64 bit words and 16 GB (2^34) bytes RAM. Assume memory block is 32 k (2^15) bytes. Virtual pages are only written to disk when a page needs to be replaced )write-back) and we use 2 bits to implement an approximate to LRU replacement strategy\
a. What is the tag size and block offset size?\
b. How big is the page table per process (assume each entry in page table uses one 64 bit word)\
c. Do we need a dirty bit? Do we need a valid bit?\
d. Page table is kept in RAM (only the most recently used parts will be in cache). HAve cache register that contains location of the page table so we can find it fast. Should the cache register contain real memory address or virtual memory address. Briefly justify.\
e. Addresses referenced in virtual addresses-so for example a load instruction references a virtual address. The cache, however, is mapped to real addresses; therefore every memory references requires a translation from virtual address to real address. Since page table is in RAM, need a memory access to get real address and a second access to get actual data minimum of 2 cycles. How do we fix this?\
}